<!-- Copyright 2012, UCAR/Unidata -->
<!- See the COPYRIGHT file for more information. -->
<html>
<style>
.break { page-break-before: always; }
body { counter-reset: H2; font-size: 12pt; }
h1 { counter-reset: H2; font-size: 12pt; }
h2:before {
  content: counter(H2) " ";
  counter-increment: H2;
}
h2 { counter-reset: H3; }
h3:before {
  content: counter(H2) "." counter(H3) " ";
  counter-increment:H3;
}
h3 { counter-reset: H4; }
h4:before {
  content: counter(H2) "." counter(H3) "." counter(H4) " ";
  counter-increment:H4;
}
h4 { counter-reset: H5; }
h5:before {
  content: counter(H2) "." counter(H3) "." counter(H4) "." counter(H5) " ";
  counter-increment:H5;
}
h6 {font-size: 16pt; margin-bottom: 0pt; padding: 0pt; } /* For TOC */
</style>
<body>

<center>
<h1>The yax Bison/YACC Based XML Parsing System</h1>
<table>
<tr><td>Created:<td>07/01/2012
<tr><td>Last Revised:<td>10/27/2012<br>
<tr><td>Version:<td>1.0
<tr><td>Status:<td>Draft
<tr><td>Author:<td>Dennis Heimbigner
<tr><td>Affiliation:<td>Unidata/UCAR
<tr><td>email:<td>dmh&#064;unida.ucar.edu
</table>
</center>

<h6><u>Table of Contents</u></h6>
<ol>
<li><a href="#Introduction">Introduction</a>
<li><a href="#Overview">Overview</a>
<li><a href="#.y">Heuristic Construction of the Bison .y Grammar File</a>
<li><a href="#yacctokens">Bison Grammar File Tokens</a>
<li><a href="#c">C Language Version</a>
<ol>
<li><a href="#xml">Example: Construct a DOM Tree</a>
<li><a href="#parserstate">Parser state</a>
<li><a href="#yylex">Bison yylex Procedure</a>
<li><a href="#dap4">Example: DAP4 DDX</a>
</ol>
<li><a href="#java">Java Language Version</a>
<ol>
<li><a href="#java-DOM">The DOM-Based Lexer</a>
<li><a href="#java-SAX">The SAX-Based Lexer</a>
<li><a href="#java-dap4dom">Example: DAP4 DDX Using a DOM Tree</a>
<li><a href="#java-dap4sax">Example: DAP4 DDX Using SAX</a>
</ol>
<li><a href="#python">Python Language Version</a>
<ol>
<li><a href="#python-SAX">The SAX-Based Lexer</a>
<li><a href="#python-dap4sax">Example: DAP4 DDX Using SAX</a>
</ol>
<li><a href="#yax">Appendix: The yax C-Language library API</a>
<li><a href="#perfecthash">Appendix: Perfect Hashing</a>
<li><a href="#references">References</a>
<li><a href="#changelog">Change Log</a>
</ol>

<h2 class="break"><a name="Introduction"><u>Introduction</u></a></h2>
The goal of the <b>yax</b> project is to allow
the use of <i>Gnu Bison</i> to parse/process XML documents.
<p>
Bison/YACC is an extremely powerful compiler generator
system.  However, little work has been applied to the
parsing and processing of XML documents using
Bison/YACC. The term "YACC" technically refers to a much
older parser generator system. GNU Bison is its modern
replacment, although its grammar file format is very
similar. The term "Bison" will be used in this document.
<p>
The key piece of software for achieving the above goal is
a library that can produce an XML lexical token
stream from an XML document.
<p>
This stream can be wrapped to create an instance of the
Bison <i>yylex()</i> procedure to feed tokens to a Bison
grammar to parse and process the XML document.
<p>
Using the stream plus a Bison grammar, it is possible
to carry at least the following kinds of activities.
<ol>
<li> Validate XML documents,
<li> Directly parse XML documents to
     create internal data structures,
<li> Construct DOM trees.
</ol>
Activity #1, Document validation, can be achieved by parsing the xml token
stream against a validation grammar. It is relatively simple
to manually convert a RELAX-NG grammar to a Bison grammar.
Parsing a document using the Bison grammar then becomes equivalent
to validating the document against the RELAX-NG grammar.
<p>
Activity #2 is the most general case. It simultaneously
validates the XML token stream against the Bison grammar
and, using Bison grammar actions, can create internal
data structures containing information extracted from
the XML document.
<p>
Activity #3, DOM trees, is actually an example of #2
where the grammar is a general grammar for xml (see the file
xml.y) and the created data structure is a DOM tree.
<p>
The <i>yax</i> system provides a general approach and support
library for producing Bison-based XML document parsers.
While it has a number of limitations, it is relatively
simple to use.
<p>
<b>WARNING: this document assumes the reader has significant
experience with both Bison and XML.</b>

<h2 class="break"><a name="Overview"><u>Overview</u></a></h2>
In order to use yax, it is necessary to manually produce the following
pieces of code.
<ol>
<li> A Bison <i>.y</i> grammar file. This file can be produced in a
straightforward way starting with a RELAXNG [1]
grammar for the XML document.
<p>
<li> A Bison yylex() procedure that can provide lexical
tokens to a Bison parser.  The yylex() program in turn wraps
the <i>yax</i> xml lexer to provide a stream of
xml-level tokens for the Bison generated parser.
</ol>

<h2 class="break"><a name=".y"><u>Heuristic Construction of the .y Grammar</u></a></h2>

Converting a RELAXNG grammar to a Bison grammar is
relatively straightforward when using the obvious RELAXNG
constructs.  Some heuristic examples are provided in the
following sections.

<h3>Start Symbol</h3>
<dl>
<dt> RELAXNG
<dd>
<pre>
&lt;start&gt;
  &lt;ref name="xxx"/&gt;
&lt;/start&gt;
</pre>
<dt> Bison
<dd>
<pre>
%start xxx
</pre>
</dl>

<h3>Simple Element</h3>
<dl>
<dt> RELAXNG
<dd>
<pre>
&lt;define name="xxx"&gt;
  &lt;element name="XXX"&gt;
  ...
  &lt;/element&gt;
</pre>
<dt> Bison
<dd>
<pre>
xxx: XXXOPEN ... XXXCLOSE
</pre>
</dl>

<h3>Element With Required Attributes</h3>
The one place where a Bison grammar has
trouble dealing with XML is with attributes.
For XML, attribute order is arbitrary.
If we have, for example, an element
with N required attributes, this must
translate into N! different rules.
This is shown in version 1 below where
representing three required attributes
forces the use of 3! = 6 rules.
Obviously this is impractical
for any significant value of N
(pretty much anything larger than N = 2).
<p>
Version 2 shows the other, better solution.
This set of rules allows, syntactically,
more possibilities than the XML, but
requires only 2*N rules. Enforcement
of the true XML rules (namely each
attribute occuring only once) must be
enforced programmatically.
<dl>
<dt> RELAXNG
<dd>
<pre>
&lt;element name="XXX"&gt;
  &lt;attribute name="a1"/&gt;
  &lt;attribute name="a2"/&gt;
  &lt;attribute name="a3"/&gt;
&lt;/element&gt;
</pre>
<dt> Bison Version 1:
<dd>
<pre>
xxx_attr_list:   A1 A2 A3 | A1 A3 A2 | A2 A1 A3
               | A2 A3 A1 | A3 A1 A2 | A3 A2 A1 ;
</pre>
<dt> Bison Version 2:
<dd>
<pre>
xxx_attr_list:
          /*empty*/
        | xxx_attr_list A1
        | xxx_attr_list A2
        | xxx_attr_list A3
        ;
</pre>
</dl>

<h3>Element With Optional Attributes</h3>
Translating optional attributes suffers
from the same rule explosion problem
as does required attributes;
actually it is worse because it requires
1+2^N rules versus N! rules.
<p>
Again, for N > 2, version 2 makes more sense.
<dl>
<dt> RELAXNG
<dd>
<pre>
&lt;element name="XXX"&gt;
  &lt;optional&gt;
    &lt;attribute name="a1"/&gt;
  &lt;/optional&gt;
  &lt;optional&gt;
    &lt;attribute name="a2"/&gt;
  &lt;/optional&gt;
&lt;/element&gt;
</pre>
<dt> Bison Version 1:
<dd>
<pre>
xxx_attr_list: /*empty*/ | A1 | A2 | A1 A2 | A2 A1 ;
</pre>
<dt> Bison Version 2:
<dd>
<pre>
xxx_attr_list:
          /*empty*/
        | xxx_attr_list A1
        | xxx_attr_list A2
        ;
</pre>
</dl>

<h3>Element Containing Required Elements</h3>
<dl>
<dt> RELAXNG
<dd>
<pre>
&lt;element name="X1"&gt;
  &lt;element name="X2"/&gt;
&lt;/element&gt;
</pre>
<dt> Bison
<dd>
<pre>
x1: X1OPEN x2 X1CLOSE ;
01: X1OPEN x2 X1CLOSE ;
x2: X2OPEN X2CLOSE ;
</pre>
</dl>

<h3>Element Containing Alternative Elements</h3>
<dl>
<dt> RELAXNG
<dd>
<pre>
&lt;element name="X1"&gt;
  &lt;choice&gt;
    &lt;element name="X2"/&gt;
    &lt;element name="X3"/&gt;
  &lt;/choice&gt;
&lt;/element&gt;
</pre>
<dt> Bison
<dd>
<pre>
x1: X1OPEN x2 X1CLOSE | X1OPEN x3 X1OPEN ;
01: X1OPEN x2 X1CLOSE | X1OPEN x3 X1OPEN ;
x2: X2OPEN X2CLOSE ;
02: X2OPEN X2CLOSE ;
x3: X3OPEN X3CLOSE ;
</pre>
</dl>

<h3>Element Containing Sequence of Alternative Elements</h3>
<dl>
<dt> RELAXNG
<dd>
<pre>
&lt;element name="X1"&gt;
  &lt;zeroOrMore&gt;
    &lt;choice&gt;
      &lt;element name="X2"/&gt;
      &lt;element name="X3"/&gt;
    &lt;/choice&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;
</pre>
<dt> Bison
<dd>
<pre>
x1: X1OPEN x1_body X1CLOSE ;
01: X1OPEN x1_body X1CLOSE ;
x1_body:
          /*empty*/
        | x1_body x2
        | x1_body x3
        ;

x2: X2OPEN X2CLOSE ;
02: X2OPEN X2CLOSE ;
x3: X3OPEN X3CLOSE ;
</pre>
</dl>

<h3>Translation</h3>
A number of obvious other heuristics, e.g. using &lt;oneOrMore&gt;,
can be constructed by simple modifications to the above heuristics.
<p>
By combining the above heuristics it is usually
possible to convert any reasonable RELAXNG grammar to a
corresponding Bison grammar.

<h2 class="break"><a name="yacctokens"><u>Bison Grammar File Tokens</u></a></h2>
The set of defined tokens in the Bison .y file typically consists of
open and close tokens for the element types and a token for
each possible attribute.
<pre>
%token <token> XXXOPEN XXXCLOSE
%token <token> YYYOPEN YYYCLOSE
...
%token <token> ATTR1
%token <token> ATTR2
...
</pre>
<p>
In addition it is convenient to define several special Bison tokens.
<ol>
<li>ERROR &ndash; a token that can be returned by yylex.
Since it is not used in any grammar rule, will cause
the parser to initiate error recovery.
<li>UNKNOWN_ATTR &ndash; represents the occurrence of
an unexpected XML attribute.
The parser action code is free to do with this as it pleases.
<li>UNKNOWN_ELEMENT_OPEN &ndash; represents the occurrence of
an unexpected XML element.
The parser action code is free to do with this as it pleases.
<li>UNKNOWN_ELEMENT_CLOSE &ndash; represents the occurrence of
an unexpected XML element as a close.
The parser action code is free to do with this as it pleases.
</ol>
<pre>
%token <token> ERROR
</pre>

<h2 class="break"><a name="c"><u>C-Language Version</u></a></h2>

<h3><a name="xml">Example: Construct a DOM Tree</a></h3>

We will illustrate the use of yax by defining a grammar &ndash; xml.y &ndash;
that processes an arbitrary xml document and produces a tree data structure
that is essentially a DOM tree.

The following sections discuss the details of the xml.y file.

<h4>Prefix Declarations</h4>
<pre>/*xml.y*/
01 %{
02 #include "xml_actions.h"
03 %}
04 
05 %union {
06     YXlist* list;
07     XMLnode* dom;
08     yax_token token;
09 }
10 
11 %lex-param {XMLparser* parser}
12 %parse-param {XMLparser* parser}
13 %error-verbose
14 %pure-parser
</pre>
The file xml_actions.h contains most of the needed declarations
for the generated xml.tab.[ch] files (line 2).
As a rule, parsers should be declared as pure (reentrant) parsers (line 14).
As a consequence, a structure is needed to hold state information
with respect to parsing a specific document. Lines 11-12 define
that structure (of type XMLparser).
<p>
The most important declaration is the "%union{...}".
It defines the possible value associated with a non-terminal or terminal.
As a rule, terminals will be tagged as of type token (i.e. yax-token)
so that the information returned by the yax lexer is accessible to
the parser actions.
<p>
As will be described in a later <a href="#lists">section</a>,
many non-terminals will have a list of values as their value.
The "list" arm of the union will tag such non-terminals.
<p>
Finally, since our goal is to construct a DOM tree, many non-terminals
will have a DOM tree node (here typed as "XMLnode") as their value.

<h4>Token and Non-Terminal Declarations</h4>
<pre>
01 %token <token> PROLOG DOCTYPE
02 %token <token> OPEN CLOSE EMPTYCLOSE
03 %token <token> ATTRIBUTE
04 %token <token> TEXT CDATA COMMENT
05 
06 /* Error support tokens */
07 %token <token> ERROR
08 
09 %type <dom> document
10 %type <dom> prolog optional_prolog
11 %type <dom> doctype optional_doctype
12 %type <dom> element attribute
13 %type <list> elementlist
14 %type <list> attributelist
</pre>
The set of Bison tokens that will be returned by <i>yylex()</i>
are defined in lines 1-4. Note that they all are marked
as having a yax-token value (via the &lt;token&gt; tag).
<p>
A special token, ERROR, is defined (line 7) that is not used
in any production. It may be returned by yylex
to cause the parser to initiate error recovery.
<p>
Lines 9-14 mark the types of the non-terminals in the grammar.
Some (lines 9-12) will return an pointer to an instance of XMLnode,
while others (lines 13-14) will return a list object (of type YXlist,
see later in this document).

<h4>Start Symbol</h4>
<pre>
01
02 %start document
03 
</pre>
The start symbol for this grammar is the "document" production.

<h4>XMLnode-Valued Productions</h4>
<pre>
01 %%
02 
03 document:
04      optional_prolog
05      optional_doctype
06      elementlist
07          {$$=xmldocument(parser,$1,$2,$3);}
08      ;
09 
10 optional_prolog: /*empty*/ {$$=NULL;} |      prolog {$$=$1;} ;
11 
12 optional_doctype: /*empty*/ {$$=NULL;} | doctype {$$=$1;} ;
13 
14 prolog:
15      PROLOG {$$=xmlprolog(parser,$1); CHECK($$);}
16      ;
17 
18 doctype:
19      DOCTYPE {$$=xmldoctype(parser,$1); CHECK($$);}
20      ;
21 
22 element:
23        OPEN attributelist EMPTYCLOSE
24          {$$=xmlelement(parser,$1,$3,$2,null); CHECK($$);}
25      | OPEN attributelist elementlist CLOSE
26          {$$=xmlelement(parser,$1,$4,$2,$3); CHECK($$);}
27      | TEXT {$$=xmlelementtext(parser,$1);}
28      | CDATA {$$=xmlelementtext(parser,$1);}
29      ;
30 attribute:
31      ATTRIBUTE {$$=xmlattribute(parser,$1);}
32      ;
</pre>
An xml document consists of an optional prolog (of the form &lt;?xml...&gt;),
followed by an optional doctype (of the form &lt;!DOCTYPE...&gt;), followed
by a list of xml elements.
An action procedure ("xmldocument()") will process these items to produce
the root node of the document DOM tree.
<p>
The yylex() procedure returns a PROLOG terminal whose value contains 
the information in the prolog declaration.
The procedure "xmlprolog()" takes the PROLOG value (of type yax-token)
and constructs an instance of an XMLnode and returns it as its value.
DOCTYPE is handled in a similar fashion.
<p>
An element non-terminal has four possible forms.
<ol>
<li> It can be a TEXT terminal, or
<li> It can be a CDATA terminal, or
<li> It can be of the form &lt;elementname attributelist /&gt;, or
<li> It can contain, recursively, a list of nested elements.
</ol>
Note that the &lt; ... /&gt; case is terminated by the terminal EMPTYCLOSE,
while the recursive case is terminated by the terminal CLOSE.
<p>
In all cases, all of the right side components are passed to a procedure
to create an instance of XMLnode.
One of the side effects of this procedure is to verify that, for example,
the &lt;e&gt; element is closed by &lt;/e&gt;.
<p>
The "attribute" production takes an ATTRIBUTE terminal and, using "xmlattribute()",
converts it to an XMLnode instance.

<h4><a name="lists">List Handling</a></h4>
<pre>
01 elementlist:
02        /*empty*/ {$$=yxlistnew();}
03      | elementlist element {$$=yxlistpush($1,(void*)$2);}
04      ;
05 
06 
07 attributelist:
08        /*empty*/ {$$=yxlistnew();}
09      | attributelist attribute {$$=yxlistpush($1,(void*)$2);}
10 
</pre>
The productions "elementlist" and "attributelist" represent a common
cliche in LALR grammars for handling repeated lists of items.
Such productions can be handled relatively uniformly using the yxlist library
provided as part of yax. It is not the only way, but it is convenient.
An alternate solution, for example, would involve linked lists.
<p>
The API defined in <i>yxlist.h</i> 
can be used to construct a list on the fly and pass
it along as rules are reduced by the parser.
<p>
In the first rule of elementlist, the action is to create an empty list
using "yxlistnew()" and return it as the value of the production (via "$$=...").
In the second rule, and by construction, the first component of the right hand side
will be of type YXlist, so we can just append the second component, an element of type
"XMLnode*" using the "yxlistpush()" procedure; casting of the second argument is needed
because YXlists are lists of "void*".
<p>
The "attributelist" production operates in an exactly analogous fashion.

<h3><a name="parserstate">Parser state</a></h3>
Because our parser is declared as reentrant, it requires
the construction of a parser state structure to hold
information about the state of the parse.
In xml.y, this parser state is an instance of the struct XMLparser.
Of course, you can use
any name you want in place of XMLparser as long as you change the
"%lex-param" and "%parse-param" declarations in the .y file
<p>
The XMLparser type is defined like this (see "xml_actions.h").
<pre>
typedef struct XMLparser {
   XMLnode* document;
   int flags;
   yax_lexer* yax;
   struct {
        int charno;
        int inopen;
   } lexer; /* extra lexer specific state */
} XMLparser;
</pre>
The fields have the following meaning.
<ol>
<li> document &ndash; holds the root XMLnode of the created DOM tree.
<li> flags &ndash; holds a combination of parse flags and yax flags.
<li> yax - this field holds the state of the yax lexer created
using the yax_create() procedure.
<li> lexer.charno &ndash; holds the character position of the last token.
<li> lexer.inopen &ndash; flag to control handling of instances of YAX_TEXT.
</ol>

<h3><a name="yylex">Bison yylex Procedure</a></h3>
The lexer is by default called "yylex",
and for our xml processor is stored in the file "xml_lexer.c".
If you review the Bison command line options,
you can change this using the "-p" flag; for xml_lexer.c,
for example, it is called xmllex by using the flag "-pxml".
<p>
The operation of the Bison-level lexer is discussed in the following
sections.

<h4>The xmllex() Arguments and local variables</h4>
<pre>/*xml_lexer.c*/
01 #define UNKNOWN -1 /* helper token */
02 
03 int
04 xmllex(YYSTYPE* lvalp, XMLparser* parser)
05 {
06     yax_err err = YAX_OK;
07     yax_token* yaxtoken = &lvalp->token;
08     int yytoken = UNKNOWN;
09 
</pre>
The "lvalp" argument is an instance of the %union
type defined in the .y file.
Since we want to access the token field of that union,
line ? extracts a pointer to that field.
<p>
The "yytoken" variable will hold the Bison token type
(e.g. OPEN, EMPTYCLOSE, etc at defined in xml.y).
<p>
The "err" variable is used to capture error indicators from
invoking "yax_nexttoken()".

<h4>The Main xmllex Loop</h4>
The main xmllex loop keeps trying to obtain a useful lexeme
from the underlying yax lexer. When yytoken has an acceptable
value (other than the pseudo-token UNKNOWN), it will exit and return
yytoken as the result of invoking xmllex.
<pre>
01     while(yytoken == UNKNOWN) {
02         err = yax_nexttoken(parser->yax,yaxtoken);
03         if(err) goto done;
</pre>
The "yax_nexttoken()" procedure is invoked
obtain a yax token. The possible set of tokens is defined
in the <a href="yaxapi">API section</a>.

<h4>Token Determination Switch</h4>
The core of the lexer is a switch
on the yax tokentype.
<pre>
01      switch(yaxtoken->tokentype) {
02         default:
03          /*report an unknown token type error*/
04          yytoken = ERROR; /* cause the parser to enter error recovery */
05          break;
06 
07      case YAX_EOF:
08          yytoken = 0;
09          break;
10 
</pre>
If an unknown token is returned, then generate an error message
using yyerror() (aka xmlerror()) and return the token ERROR
to initiate parser error recovery.
<p>
If yax_nexttoken() returns end-of-file, then return 0 as the value
of yytoken to tell the parser that end of input was encountered.

<h4>Simple Cases</h4>
The following yax token type cases more or less convert
the yax tokentype to a Bison token type in the obvious way.
These case are: YAX_OPEN, YAX_EMPTYCLOSE, YAX_CLOSE, YAX_ATTRIBUTE,
YAX_PROLOG, and YAX_DOCTYPE.
They all have the form something like this.
<pre>
01      case YAX_PROLOG:
02          yytoken = PROLOG;
03          break;
04 
</pre>

<h4>Comments</h4>
<pre>
01      case YAX_COMMENT:
02          continue; /* ignore */
03 
</pre>
This particular lexer suppresses comments and loops
again to get the next yax token.

<h4>Handling TEXT Elements</h4>
<pre>
01      case YAX_TEXT: {
02          /* We only want to return TEXT
03              when we are inside an OPEN.
04              If it occurs elsewhere and is not whitespace,
05              then fail.
06          */ 
07          if(parser->lexer.inopen) {
08              yytoken = TEXT;
09          } else {
10              char* p = yaxtoken->text;
11              /* check for whitespace */
12              for(;*p;p++) {if(!iswhitespace(*p)) goto fail;}
13              /* suppress whitespace */
14              continue; /* look for another token */
15          }
16      } break;
</pre>
When yax_nexttoken returns a token of type YAX_TEXT, we have
to handle it. There are three possibilities.
<ol>
<li> The text instance occurs inside an openelement-closelement pair:
&lt;element&gt;...&lt;/element&gt;.
<li> The text instance occurs outside of case 1, but the text contains
only whitespace characters.
<li> The text instance occurs outside of case 1, but the text contains
non-whitespace characters.
</ol>
For case 1, we should return a Bison-level TEXT token.
For case 2, we should ignore the YAX_TEXT token.
For case 3, we should declare an error.
Without going into detail, we determine
our case using a parser state flag.

<h4>The xmllex Return Value</h4>
<pre>
done:
    parser->lexer.charno = yaxtoken->charno;
    return yytoken;
fail:
    yytoken = ERROR;
    goto done;
}
</pre>
The fail label sets yytoken to the Bison ERROR token
and then returns. The normal return (label done:)
saves the character position of the token vis-a-vis
the input document. Then it returns the value of yytoken
as the value of xmllex.

<h3><a name="dap4">Example: DAP4 DDX</a></h3>
For a second example, the DAP4 DDX [2] is parsed.
The provided code only does validation; no
data structure is constructed.
This example demonstrates some additional
elements in using yax plus Bison.

<h4>The DAP4 Grammar File</h4>
The Bison grammar file ("dap4.y") is very similar in structure
to "xml.y" shown previously.
It differs in several aspects.
<ol>
<li>Element specific open and close tokens are used.
For example, for the &lt;Group&gt; element,
two tokens are defined: the open token GROUP_
and the corresponding close token _GROUP.
<p>
<li>Attribute specific tokens are defined. So the attribute
"name", has a corresponding ATTR_NAME Bison token.
<li>In some places, unexpected attributes are allowed,
and so Bison token, UNKNOWN_ATTR, is defined.
<p>
<li>In addition to the special ERROR token,
two additional tokens are defined: UNKNOWN and UNEXPECTED
to signal special cases of ERROR.
<p>
<li>Since some of the elements have multiple allowed
attributes, the list-based technique defined 
<a href="#.y">previously</a> is used.
<p>
<li>Since we are doing only validation, no %union{...}
is needed and no token or non-terminal typing is required.
This means that the only part of a terminal of interest
is its Bison token value.
</ol>

<h4>The DAP4 yylex()</h4>
The <i>dap4lex()</i> procedure, the Bison-level lexer
is again similar to xml_lexer.c but with some notable
differences. It is described in the following sections.

<h5>Lexer Declarations</h5>
<pre>/*dap4_lexer.c*/
01 int
02 dap4lex(YYSTYPE *lvalp, DAP4parser* parser)
03 {
04 yax_token yaxtoken;
05 struct dap4_keyword {
06   char *name; int opentag ; int closetag; int attributetag;
07 } keyword;
</pre>
Since we are doing validation only, the lvalp argument is unused.
The DAP4parser type is, like XMLparser previously, for holding parser
specific state.
<pre>
typedef struct DAP4Parser {
    yax_lexer* yaxlexer;
} DAP4parser;
</pre>
In this case, it holds the minimal possible,namely the yax lexer state.
<p>
We do need a yax token instance to pass into yax_nexttoken(),
so it is defined as a local variable to dap4lex().
As described below, we will need a special struct to use with
our perfect has function described subsequently.

<h5>The dap4lex Main Loop</h5>
<pre>
    while(yytoken == UNKNOWN) {
        err = yax(parser->lexstate,yaxtoken);
        if(err) goto done;

        if(tokenstate->name != NULL)
            keyword = dap4_keyword_lookup(tokenstate->name,
                                          strlen(tokenstate->name));
</pre>
In this parser, it is useful to quickly convert a name (e.g. an element or
attribute name) returned by yax_nexttoken() to a corresponding Bison token:
map "Group" to GROUP_ and _GROUP for example.
<p>
In this case we use a perfect hash function generated
by the Gnu gperf program [3] as described in an
<a href="#perfecthash">Appendix</a>.
<p>
If the hash function returns NULL, then we have an unknown/unexpected
element or attribute name and can return UNKNOWN_ELEMENT_OPEN,
UNKNOWN_ELEMENT_OPEN, UNKNOWN_ATTRIBUTE as appropriate.
<p>
Otherwise,
if we have a YAX_OPEN token, we can return keyword->opentag.
If we have a YAX_CLOSE or YAX_EMPTYCLOSE token, we can return keyword->closetag.
If we have a YAX_ATTRIBUTE token, we can return keyword->attributetag.

<h2 class="break"><a name="java""><u>Java Language Version</u></a></h2>
There are actually two different java implementations.
<ul>
<li> A DOM based version that generates tokens by walking
the DOM tree in prefix, left-to-right, depth-first order.
<p>
<li> A Sax based version that runs a Sax parser, converts events
to Bison tokens, and invokes a Java Bison push parser.
</ul>
There is no direct equivalent of <i>yax.c</i> because
standard Java includes support for DOM trees and Sax parsers.
<p>
Is is assumed that the reader is familiar with the
the Java parser section of the bison documentation.

<h3><a name="java-DOM">The DOM-Based Lexer</a></h3>
<p>
The basic idea is that one has a single class, <i>DomLexer</i>,
that is given an org.w3c.dom.Document object as the root of a
DOM tree. The <i>Domlexer</i> class walks that tree in
prefix order, left-to-right, depth-first for
attributes and children.
<p>
For each type of DOM node, it is mapped to a token type
that matches those defined in the C yax_tokentype.
The Bison "yylex" lval for the token is the DOM tree node.
<p>
The net result is that it is generally possible to have the
same core grammar for both C and Java, to have similar, but
not identical, versions of yylex and similar, but not
identical, action procedures.

<h4><a name="java-lexeme">Java Lexeme Class</a></h4>
A class called <i>Lexeme</i> is defined. Its purpose
is to hold relevant information about
either a legal XML element or a legal XML attribute.
The class <i>Lexeme</i> is defined as follows.
<pre>
01 public class Lexeme
02 {
03     public String name; // element or attribute name
04     public int open;    // Bison token for element open
05     public int close;   // Bison token for element close
06     public int atoken;  // Bison token if this is an attribute
07     public String[] legalAttributes;
08     ...
09 }
</pre>
Optionally, a list of legal attributes can be stored
and the developers subclass of SaxEventHandler can
reference it to quickly detect illegal/unknown attributes
before they are passed to the parser. This is mostly
unnecessary as the parser will detect unexpected attributes
anyway.
<p>
An instance is created for each possible legal element name
or attribute name. For elements, the corresponding Bison
open token and close token are defined. For attributes,
the single attribute atoken is defined.
<p>
Optionally, a list of legal attributes can be stored
and the developers subclass of SaxEventHandler can
reference it to quickly detect illegal/unknown attributes
before they are passed to the parser. This is technically
unnecessary as the parser will detect unexpected attributes
anyway.
<p>
The <i>Lexeme</i> class is used in conjunction with two
maps of type <i>Map&lt;String,Lexeme&gt;</i>.
The two maps are the elementmap and the attributemap.
<p>
The reason for this seeming complexity of using the class <i>Lexeme</i>
is that it makes the Bison lexer very generic. By changing the lexemes
in the element and attribute map, the bison level lexer can
be reused for a wide variety of xml-based grammars.

<h4><a name="java-DOMMAP">Mapping DOM nodes</a></h4>

The mapping of the DOM node to a Bison token integer and
yylvalue is somewhat convoluted, but the basic idea is
similar to the <i>struct dap4_keyword</i> in the
<a href="#dap4">DAP4 DDX Example</a>.
<p>
The bison level token integer is determined as follows.
<ol>
<li> Get the string name from the Node (assuming it is an element
or attribute).
<p>
<li> Probe the <i>elementmap</i> or <i>attributemap</i>
to obtain a matching lexeme.
<p>
<li> If the map probe returns null, then generate a token
indicating unknown element or attribute.
<p>
<li> Otherwise, if we are processing a a DOM element node,
then process the node to return, in order,
  <ol>
  <li> An OPEN token corresponding to the node's name,
  <li> A sequence of ATTRIBUTE tokens, and finally
  <li> A CLOSE token corresponding to the node's name.
  </ol>
</ol> 

<h3><a name="java-dap4dom">Example: DAP4 DDX Using a DOM Tree</a></h3>
This example does the DAP4 DDX in Java. It is instructive
to compare it with the <a href="#dap4">C version</a>.
As with the C version, only validation is performed;
no data structure is constructed.

<h4>The DAP4 Grammar File</h4>
The Bison grammar file ("dap4.dom.y") is used mostly unchanged
from the C version. The prefix part, the part before the
token declarations, differs, but the rest can be the same.
<p>
The Java parser generated by Bison does not support the
%union{...} construct. Rather, YYSTYPE is defined always
to be an instance of the Java <i>Object</i> class.

<h4>The Java DAP4 yylex()</h4>
The .y file header specifies the generated parser class name
using the "%define parser_class_name" directive:
<i>Dap4DomParser</i> in this case.
All other names are fixed, so, the lexer is always of the type
of the inner interface <i>Lexer</i> within Dap4DomParser.
<p>
The Lexer interface has three defined methods.
<dl>
<dt><i>Object getLVal()</i>
<dd>Method to retrieve the semantic value of the last scanned token.
For yax, this will always be an instance of <i>org.w3c.Dom.Node</i>
coming from the underlying DOM tree that is being walked as described
previously. Note that the same node may be returned twice: once
as the open element lval and once as the close element lval.
<p>
<dt><i>int yylex() throws Exception</i>
<dd> Entry point for the scanner.
Returns the token identifier corresponding to the next token
and prepares to return the semantic value of the token.
<p>
<dt><i>void yyerror(String s)</i>
<dd>Entry point for error reporting.
Emits an error in a user-defined way.
</dl>
<p> 
The code for this Bison-level lexer is described in the
following sections.

<h5>Dap4DomLexer Class</h5>
<pre>
01 /*Dap4DomLexer.java*/
02 class Dap4DomLexer implements Dap4Parser.Lexer
03 {
04     // Instance Variables
05     DomLexer domlexer = null;
06     Node lval = null;
</pre>
The instance variables have the following meaning.
<ul>
<li>The lexer is an instance of <i>DomLexer</i>
for walking the given DOM tree.
<li>The lval holds the last org.w3c.dom.Node value
returned by the DOM tree domlexer;
</ul>
There are two parts of most interest: element plus map creation,
and conversion of DOM nodes to Bison tokens.

<h5>Map Creation</h5>
The construction of
the <i>elementmap</i> and <i>attributemap</i>
maps is done statically.
<pre>
01 static Map<String,Lexeme> elementmap;
02 static Map<String,Lexeme> attributemap;
03 
04 static {
05     elementmap = new HashMap<String,Lexeme>();
06     attributemap = new HashMap<String, Lexeme>();
07 
08     elementmap.put("Group",
09                    new Lexeme("Group",GROUP_,_GROUP,
10                    new String[]{"name","dapversion","ddxversion",
11                    "ns","base","xmlns"}));
12 
13     ...
14     attributemap.put("base",new Lexeme("base",ATTR_BASE));
15     ...
16 };
</pre>
The maps are populated with put operations (lines 8 and 14).
Note the ordered list of attribute names
that is the last argument of the <i>new Lexeme("Group"...)</i>
constructor (line 10-11). Note also that the attribute map insertion names
(the first argument to attributemap.put) should be lower case.

<h5>Constructor</h5>
<pre>
01 public Dap4DomLexer(String input)
02 throws Exception
03 {
04     domlexer = new DomLexer(input);
05 }
</pre>
The constructor creates a DomLexer instance (line 4).

<h5>The yylex() Procedure Part 1</h5>
<pre>
01 public int
02 yylex()
03 throws Exception
04 {
05     int yytoken = UNKNOWN;
06     String name;
07     DomEventType yaxtoken = DomEventType.UNDEFINED;
08     
09     while(yytoken == UNKNOWN) {
10         yaxtoken = domlexer.nextToken(nodep);
11         lval = domlexer.nextNode();
12     
13         short ttype = lval.getNodeType();
14         String ttypename = Util.nodetypeName(ttype);
15         name = lval.getNodeName();
16         Lexeme element = elementmap.get(name);
</pre>
The nodep variable is a one element array to provide a pseudo
call by reference in Java. The DOM tree domlexer needs to return two
things: a yax token type (defined in the class yax.lex.Type)
and the org.w3c.dom.Node instance. It returns the former
as its value and the latter is obtained by immediately calling
the <i>nextNode()</i> method (line 11).
<p>
The DOM node name is used with the element map to obtain a
Lexeme instance for mapping to specific Bison level tokens.
<p>
If the element map does not contain the requested name,
then we have an unknown/unexpected
element or attribute name and can return UNKNOWN_ELEMENT_OPEN
if desired, or an exception could be thrown.

<h5>The yylex() Procedure Part 2</h5>
<pre>
01          switch(yaxtoken) {
02  
03          case OPEN: 
04          ...
05          case CLOSE:
06          ...
</pre>
The switch here is similar to that in the C code.
It switches on the yax token value returned from the
DomLexer.nexttoken() call.
<p>
As with the C code,
if we have a YAX_OPEN token, we can return element.open;
If we have a YAX_CLOSE or YAX_EMPTYCLOSE token, we can return element.close.
If we have a YAX_ATTRIBUTE token, we can probe the attribute map
and, if defined, return attr.atoken.
<p>
One special note for the Dap4 grammar.
The element <value> can have enclosed text representing the value.
This is tested
for in the OPEN switch arm and a flag is set.
This flag will be acted on in the TEXT
switch arm and cause it to pass a Bison TEXT token to the Bison push
parser.

<h3><a name="java-SAX">The SAX-Based Lexer</a></h3>
Using a Sax parser has the advantage over the DOM-based parser
in that it is not necessary to build the explicit DOM tree.
<p>
The Sax parser operates by producing a series of "events"
representing elements in the xml document: start element, 
end element, etc.
A subset of the possible events is given to the user-defined
handler to process the events.
<p>
Gnu Bison has a notion called "push-parsing" where the
parser is fed lexemes one by one. This is essentially
the same model as a Sax parser where the Sax events serve
the role of tokens and the Sax parser is a push-parser in Bison
terms.
As of Bison version 3.0, Java push parsing support is standard.
<p>
The primary interface to the Bison generated push-parser
uses this method call.
<pre>
public int push_parse(int yylextoken, Object yylexval)
</pre>
<p>
The yax Sax parser operates by setting up a Sax event handler
object of class <i>SaxEventHandler</i>.
The <i>SaxEventHandler</i> class
contains a collection of callback methods invoked to process
each kind of Sax event.
Each callback method takes each event and converts it to a instance
of the class <i>SaxEvent</i>.
This token captures all of the
relevant information from the event.
<p>
In practice, the developer defines a subclass
of <i>SaxEventHandler</i> to actually process
the <i>SaxEvent</i> object and convert it to a
<i>yylexval</i> and <i>yytoken</i> arguments
to the Bison push-parser.
<p>
The notional architecture stack for this kind of parsing
looks like the following.
<pre>
     -------------------
    |      Main         |
     -------------------
    |    Sax Parser     |
     -------------------
    | Sax Event Handler |
     -------------------
    | Sax Event Handler |
    |     subclass      |
     -------------------
    | Bison push-parser |
     -------------------
</pre>
The corresponding processing flow is as follows.
<ol>
<li> The main program invokes the Sax parser.
<li> The Sax parser parses the xml document and generates
a series of callbacks into the <i>SaxEventHandler</i> class.
<li> That class in turn creates an instance of <i>SaxEvent</i>
and calls the subclass defined <i>yyevent</i>() method.
<li> The subclass defined <i>yyevent</i> method
translates the event into a token plus yylval
suitable for use by a Bison parser. It then sends that token 
and lval to the Bison push parser. 
</ol>
Any exceptions generated by either the Sax event handler or the Bison
push parser should be rewrapped as a SAXException
so that they propagate up the stack correctly.
<p>
In practice the stack above is internalized into the
user defined subclass of <i>SaxEventHandler</i>.
The stack above is created by the event handler's 
<i>parse()</i>method.
<p>
For the purposes of invoking the <i>push_parse</i> method of the Bison
parser, the yylexval argument is the current instance of
 <i>SaxEvent</i> and the yylextoken argument is an integer
derived from the <i>SaxEvent</i> instance.
<p>
The bison level token integer is generically
determined as follows.
<ol>
<li> Get the string name from the Sax token (assuming it is an element
or attribute).
<p>
<li> Probe the <i>elementmap</i> or <i>attributemap</i>
to obtain a matching lexeme.
<p>
<li> If the map probe fails, then throw an exception
indicating unknown element or attribute. Alternatively,
generate a special token called, say, UNKNOWN_ELEMENT
or UNKNOWN_ATTRIBUTE, and pass it to the parser.
<p>
<li> Otherwise, if we are processing a <i>STARTELEMENT</i>
event (equivalent to the Sax <i>startElement</i> callback)
then return the <i>open</i> field of the lexeme
as the Bison-level token integer.
<p>
This event also processes the attributes of the element
and passes them one by one to the parser using a synthetic
<i>ATTRIBUTE</i> event.
<p>
<li> If we are processing an <i>ENDELEMENT</i> event,
then return the <i>close</i> field of the lexeme
as the Bison-level token integer.
</ol> 

<h3><a name="java-dap4sax">Example: DAP4 DDX Using SAX</a></h3>
This is the same example as the <a href="#java-dap4dom">previous
example</a>, but using the class <i>SaxLexer</i> instead of
<i>DomLexer</i>.

<h4>The DAP4 Grammar File</h4>
The Bison grammar file ("dap4.y") is
essentially the same as the DOM version with these
exceptions.
<ol>
<li> The parser class name is different,
<li> A push parser is specified using the "%define api.push-pull push"
directive.
<li> The lexer uses "%code lexer {...}"; see below.
</ol>

<h4>The Bison Grammar API for Sax</h4>
Technically, the Bison parser has no need for access
to a lexer because any output from the lexer
is passed into the Bison parser through the <i>push_parser</i>
method arguments. However, the parser does need access
to the lexer's <i>yyerror</i> procedure, so we do need 
at least a stub lexer to the parser.
This is handled by defining the lexer using the Bison
<i>%code lexer</i>
construct. It is generically defined like this.
<pre>
%code lexer {
  public Object getLVal() {return null;}
  public int yylex() {return 0;}
  public void yyerror(String s) {System.err.println(s);}
}
</pre>
The only
method in the lexer interface that will be called is
<i>yyerror</i>, so the others are stubs. The actual
aaction of <i>yyerror</i> can, of course, be changed
as desired.

<h4>SaxEventHandler Class</h4>
The <i>SaxEventHandler</i> class is the primary
class for the Sax-based parser.
The developer will subclass it to create a grammar
specific event handler.
<p>
The SaxEventHandler constructor takes a String as its argument.
The argument is the document to be parsed.
<p>
A selected subset of the events received by SaxEventHandler
are passed to the subclass by funneling them into a 
single, subclass defined, method <i>yyevent</i> with the
following signature.
<pre>
abstract public void yyevent(SaxEvent event) throws SAXException;
</pre>
<p>
The <i>yyevent</i> method is the primary interface
for event handling by the developer. As SaxEventHandler gets an event,
via callback invocation, from the
Sax parser, it transforms the callback arguments
into an instance of <i>SaxEvent</i>
and sends it to the subclass for handling using this method.
<p>
<i>SaxEvent</i> is defined as follows.
<pre>
01 public class SaxEvent
02 {
03     public SaxEventType event = null;
04     public Type type = null;
05     public String name = null;
06     public String fullname = null;
07     public String namespace = null;
08     public String value = null; // for attributes
09     public String text = null;  // for text
10     public String publicid = null;
11     public String systemid = null;
12     public Locator locator = null;
13     ... constructors ...
14 }
</pre>
The event's <i>event</i> field (of type SaxEventType)
records the type of SAX event (effectively the callback)
that was used to generate this instance.
The <i>type</i> field is the result of mapping
the SaxEventType enumeration to the yax.lex.Type enumeration.
The mapping may result in a null value.
The other fields are, hopefully, obvious.
The callbacks in <i>SaxEventHandler</i> may be consulted
to see how the arguments to the callback are stored in the
<i>SaxEvent</i> instance. 

<h5>StartElement Event Processing</h5>
The code for the "startElement" event is the most complicated.
<pre>
01 public void startElement(String nsuri, String name, String qualname,
02                          Attributes attributes)
03 {
04     throws SAXException
05     SaxEvent event = new SaxEvent(SaxEventType.STARTELEMENT,locator,name,qualname,nsuri);
06     yyevent(event);
07     // Now pass the attributes as tokens
08     int nattr = attributes.getLength();
09     for(int i=0;i&lt;nattr;i++) {
10         String aname = attributes.getLocalName(i);
11         if("".equals(aname)) aname = attributes.getQName(i);
12         String value = attributes.getValue(i);
13         token = new SaxToken(SaxEventType.ATTRIBUTE,locator,aname);
14         token.value = value;
15         yyevent(token);
16     }
17 }
</pre>
This event handler must generate an OPEN event first (line 5)
and then it must generate events for each attribute in turn (lines 8-16).

<h5>Other Event Processing</h5>
<pre>
01 public void endElement(String nsuri, String name, String qualname)
02     throws SAXException
03 {
04     SaxEvent event = new SaxEvent(SaxEventType.ENDELEMENT,locator,name,
05                                   qualname,nsuri);
06     yyevent(event);
07 }
</pre>
Most other events are handled in a fashion similar to the endElement
event. In this example, a SaxEvent is created to contain the arguments of the
endElement method and the SaxEvent instance is sent to the subclass's
<i>yyevent</i> method.

<h5>Parsing Invocation</h5>
The signature for the primary parse invocation method
in the <i>SaxEventHandler</i> is as follows.
<pre>
public boolean parse() throws Exception
</pre>
Parsing is initiated by calling the SaxEventHandler's <i>parse</i> method
in the SaxEventHandler class.
The default version in SaxEventHandler is generally ok to use, but
the subclass can override it to do extra processing.
<p>
The <i>parse</i> methods takes the following
steps.
<ol>
<li> Create an instance of <i>javax.xml.parsers.SAXParser</i> via the
      <i>SAXParserFactory</i> class.
<li> Invoke the <i>parse</i> method of the SAXParser and providing both the
      document to be parsed as well as the SaxEventHandler to handle the
      events generated by the SAXParser. 
</ol>

<h4>Dap4SaxHandler Class</h4>
This example defines a class as a subclass of the
<i>SaxEventHandler</i> class;
this example class would be created by the developer.
<p>
There are two parts of most interest: element plus map
creation, and event processing.
Map creation is the same as is described
for <i>Dap4DomLexer</i>.


<h5>The yyevent() Method Part 1</h5>
The most important part of the Dap4SaxEventHandler class
is the <i>yyevent</i> method. It takes
a SaxEvent, converts it to a form usable by by the Bison
push parser, and invokes the push parser.
<p>
<pre>
01     if(accepted)
02         throw new SAXException("yyevent called after parser has accepted");
03     DomEventType yaxtoken = saxevent.type;
04     String name = saxevent.name;
05     element = elementmap.get(name);
06     attr = attributemap.get(name);
07     switch(yaxtoken) {
08         ...
09     }
</pre>
To begin with, a check is made to ensure that the event processor it not
invoked after the parser has entered an accept state (lines 1-2).
Next, yyevent probes the element map to see if the
<i>SaxEvent</i> name field is known (lines 5-6).
It then switches on the SaxEvent type field to process each
kind of event (line 7).
<p>
It is important to note that the SaxEvent type
field (of type yax.lex.Type) was generated from the SaxEvent event
field, which is of type yax.lex.SaxEvent). The mapping is defined in the
SaxEvent class. In effect, only a subset of the possible sax events are
passed to the subclass.

<h5>The yyevent() Method Part 2</h5>
<pre>
01 case OPEN: 
02     if(element == null) {// undefined
03         yytoken = UNKNOWN_ELEMENT_;             
04     } else {
05         yytoken = element.open;
06         // Check for the special case of  */
07         if(yytoken == VALUE_)
08             textok = true;
09     }
10     break;
</pre>
The OPEN case (corresponding to the STARTELEMENT event) checks to see if
the element name was
in the element map (line 2). If it is undefined, then use
the Bison token integer <i>UNKNOWN_ELEMENT_</i>. Otherwise,
use the token specified by the element's lexeme open field
(line 5).
<p>
<p>
As with the DOM lexer, we handle the special case of &lt;value&gt;
with the textok flag.
<p>
Most of the other switch arms are obvious; they just map to a Bison
token integer and exit the switch.

<h5>The yyevent() Method Part 3</h5>
<pre>
01 int status = 0;
02 try {
03     status = pushparser.push_parse(yytoken,saxevent);
04 } catch (Exception e) {throw new SAXException(e);}
05 if(status == YYABORT)
06     throw new SAXException("YYABORT");
07 else if(status == YYACCEPT)
08     accepted = true;
</pre>
The Bison push parser's push_parse method is invoked with the Bison
integer token computed in the prior switch and with the SaxEvent as the
lval (line 3). Exceptions from the parser are just rethrown as a
SAXException (line 4).
<p>
If the parser aborts, a corresponding abort exception is thrown (line 6).
If the parser accepts, then this is noted so that the code can
complain if an attempt is made to continue parsing (lines 7-8).

<h2 class="break"><a name="python""><u>Python Language Version</u></a></h2>
Unlike Java, only a Sax-based parser is supported.
The Sax based version runs a Sax parser, converts events
to Bison tokens, and invokes a Python Bison push parser.
There is no direct equivalent of <i>yax.c</i> because
standard Python includes support for Sax parsers.
<p>
Is is assumed that the reader is familiar with both the
Java section of this document and the Python parser
section of the bison documentation.

<h3><a name="python-SAX">The SAX-Based Lexer</a></h3>
The Sax parser operates by producing a series of "events"
representing elements in the xml document: start element, 
end element, etc.
A subset of the possible events is given to the user-defined
handler to process the events.
<p>
Gnu Bison has a notion called "push-parsing" where the
parser is fed lexemes one by one. This is essentially
the same model as a Sax parser where the Sax events serve
the role of tokens and the Sax parser is a push-parser in Bison
terms.
Bison parsers do not yet support
Python push parsing. However, the author
has contributed a Python push parser skeleton to the Bison
project that supports Python push parsing. That skeleton
will be in the standard bison release at some point.
<p>
The primary interface to the Bison generated push-parser
uses this method call.
<pre>
def push_parse(yylextoken, yylexval):
</pre>
<p>
The yax Sax parser operates by setting up a Sax event callback
object of class <i>SaxEventHandler</i>
(in module saxeventhandler.py).
<i>SaxEventHandler</i> class is derived (mainly) from the
xml.sax.handler.ContentHandler class.
The callback takes each event and converts it to a instance
of the class <i>SaxEvent</i> (in module saxevent.py).
This token captures all of the
relevant information from the event.
<p>
In practice, the developer defines a subclass
of <i>SaxEventHandler</i> to actually process
the <i>SaxEvent</i> object and convert it to a
<i>yylexval</i> and <i>yytoken</i> arguments
to the Bison push-parser.
<p>
The notional architecture stack for this kind of parsing
looks like the following.
<pre>
     -------------------
    |      Main         |
     -------------------
    |    Sax Parser     |
     -------------------
    | Sax Event Handler |
     -------------------
    | Sax Event Handler |
    |     subclass      |
     -------------------
    | Bison push-parser |
     -------------------
</pre>
The corresponding processing flow is as follows.
<ol>
<li> The main program invokes the Sax parser
<li> The Sax parser parses the xml document and generates
a series of callbacks into the <i>SaxEventHandler</i> class.
<li> That class in turn creates an instance of <i>SaxEvent</i>
and calls the subclass defined <i>yyevent</i>() method.
<li> The subclass <i>yyevent</i> method
translates the event into a token plus lval
suitable for use by a Bison parser. It then sends that token to the
Bison push parser. 
</ol>
Any exceptions generated by either the Sax event handler or the Bison
push parser should be rewrapped as a SAXException
so that they propagate up the stack correctly.
<p>
In practice the stack above is internalized into the
user defined subclass of <i>SaxEventHandler</i>.
The stack above is created by the event handler's 
<i>parser()</i>method.
<p>
For the purposes of invoking the <i>push_parse</i> method of the Bison
parser, the yylexval argument is the current instance of
a <i>SaxEvent</i> and the yylextoken argument is an integer
derived from the <i>SaxEvent</i> instance.
<p>
The bison level token integer is generically
determined as follows.
<ol>
<li> Get the string name from the Sax token (assuming it is an element
or attribute).
<p>
<li> Probe the <i>elementmap</i> or <i>attributemap</i>
to obtain a matching lexeme. These maps are defined
as python dictionary objects mapping strings to instances
of class <a href="#python-lexeme"><i>Lexeme</i></a>.
<p>
<li> If the map probe fails, then throw an exception
indicating unknown element or attribute. Alternatively,
generate a special token called, say, UNKNOWN_ELEMENT
or UNKNOWN_ATTRIBUTE, and pass it to the parser.
<p>
<li> Otherwise, if we are processing a <i>STARTELEMENT</i>
event (equivalent to the Sax <i>startElement</i> callback)
then return the <i>open</i> field of the lexeme
as the Bison-level token integer.
<p>
This event also processes the attributes of the element
and passes them one by one to the parser using a synthetic
<i>ATTRIBUTE</i> event.
<p>
<li> If we are processing an <i>ENDELEMENT</i> event,
then return the <i>close</i> field of the lexeme
as the Bison-level token integer.
</ol> 

<h3><a name="python-lexeme">Python Lexeme Class</a></h3>
In order to make it easy to define the user defined
subclass of <i>SaxEventHandler</i>, a class called <i>Lexeme</i>
is defined. Its purpose is to hold relevant information about
either a legal XML element or a legal XML attribute.
The class <i>Lexeme</i> is defined as follows.
<pre>
01 class Lexeme:
02   def __init__() :
03     self.name = None # element or attribute name
04     self.open = 0    # Bison token for element open
05     self.close = 0   # Bison token for element close
06     self.atoken = 0  # Bison token if this is an attribute
07     self.legalAttributes = ()
</pre>
An instance is created for each possible legal element name
or attribute name. For elements the corresponding Bison
open token and close token are defined. For attributes,
the single attribute atoken is defined.
<p>
Optionally, a list of legal attributes can be stored
and the developers subclass of SaxEventHandler can
reference it to quickly detect illegal/unknown attributes
before they are passed to the parser. This is technically
unnecessary as the parser will detect unexpected attributes
anyway.

<h3><a name="python-dap4sax">Example: DAP4 DDX Using SAX</a></h3>

<h4>The DAP4 Grammar File</h4>
The Bison grammar file ("dap4.y") is essentially the same as
the <a href="#dap4sax">Java SAX version</a> except that, of course,
the language is specified as "Python".

<h4>The Bison Grammar API for Sax</h4>
As with the Java version, the python
Bison parser has no need for access
to a lexer because any output from the lexer
is passed into the Bison parser through the <i>push_parser</i>
method arguments. However, the parser does need access
to the lexer's <i>yyerror</i> procedure, so we do need 
at least a stub lexer to the parser.
This is handled by defining the lexer using the Bison
<i>%code lexer</i> construct. It is generically defined like this.
<pre>
%code lexer {
  def yylex() : return (0,None)
  def yyerror(s) : sys.stderr.write(s+'\n')
}
</pre>
The only
method in the lexer interface that will be called is
<i>yyerror</i>, so the other is a stub. The actual
action of <i>yyerror</i> can, of course, be changed
as desired.

<h4>SaxEventHandler Class</h4>
The <i>SaxEventHandler</i> class is the primary
class for the Sax-based parser.
The developer will subclass it to create a grammar
specific event handler.
<p>
The SaxEventHandler constructor takes either a String as its argument
or an instance of the <i>xml.sax.xmlreader.InputSource</i> class.
If the argument is a string then it is assumed to be
the document to be parsed. If it is an instance of <i>InputSource</i>,
then it is passed directly to the Sax parser.
<p>
A selected subset of the events received by SaxEventHandler
are passed to the subclass by funneling them into a 
single, subclass defined, method <i>yyevent</i> with the
following signature.
<pre>
def yyevent(event):
</pre>
where the event argument is an instance of <i>Saxevent</i>.
<p>
The <i>yyevent</i> method is the primary interface
for event handling by the developer. As SaxEventHandler gets an event,
via callback invocation, from the
Sax parser, it transforms the callback arguments
into an instance of <i>SaxEvent</i>
and sends it to the subclass for handling using this method.
<i>SaxEvent</i> is defined as follows.
<pre>
01 class SaxEvent:
02
03   def __init__(self) :
04     self.event = None     # of type SaxEventType
05     self.name = None      # of type String
06     self.fullname = None  # of type String
07     self.namespace = None # of type String
08     self.value = None     # for attributes; of type String
09     self.text = None      # for text ; of type String
10     self.publicid = None  # of type String
11     self.systemid = None  # of type String
12     self.locator = None   # of type Locator
</pre>
The event's <i>event</i> field (of type SaxEventType)
records the type of SAX event (effectively the callback)
that was used to generate this instance.
The other fields are, hopefully, obvious.
The callbacks in <i>SaxEventHandler</i> may be consulted
to see how the arguments to the callback are stored in the
<i>SaxEvent</i> instance. 

<h5>StartElement Event Processing</h5>
The code for the "startElement" event is the most complicated.
<pre>
01   def startElement(self, name, attributes) :
02     event = new SaxEvent(SaxEventType.STARTELEMENT,self.locator,name)
03     yyevent(event);
04     # Now pass the attributes as tokens
05     nattr = attributes.getLength()
06     names = attributes.getNames()
07     for i in range(0,nattr) :
08       aname = names[i]
09       value = attributes.getValue(aname)
10       token = SaxEvent(saxeventtype.ATTRIBUTE,self.locator,aname)
11       token.value = value
12       self.yyevent(token)
</pre>
This event handler must generate a STARTELEMENT event first (line 2)
and then it must generate events for each attribute in turn (lines 7-12).

<h5>Other Event Processing</h5>
<pre>
01   def endElement(name) :
02     event = new SaxEvent(SaxEventType.ENDELEMENT,self.locator,name)
03     self.yyevent(event);
</pre>
Most other events are handled in a fashion similar to the endElement
event. In this example, a SaxEvent is created to contain the arguments of the
endElement method and the SaxEvent instance is sent to the subclass's
<i>yyevent</i> method.

<h5>Parsing Invocation</h5>
The signature for the primary parse invocation method
in the <i>SaxEventHandler</i> is as follows.
<pre>
def parse(self):
</pre>
Parsing is initiated by calling the SaxEventHandler's <i>parse</i> method
in the SaxEventHandler class.
The default version in SaxEventHandler is generally ok to use, but
the subclass can override it to do extra processing.
<p>
The <i>parse</i> methods takes the following
steps.
<ol>
<li> Obtain an instance of <i>xml.sax.xmlreader.InputSource</i>.
     This can be done in one of two ways.
     <ol>
     <li> If the original source is a string, then
          create an InputSource instance capable of reading
          from that string.
     <li> If the original source is already an <i>InputSource</i>,
          then use it unchanged.
     </ol>
<li> Create a parser (an instance of XMLReader)
     using <i>xml.sax.make_parser()</i>.
<li> Set the content handler of the parser to be
     self (i.e. the event handler).
<li> Invoke the <i>parse</i> method of the parser and providing the
     <i>InputSource</i> created in step 1 as its argument.
</ol>

<h4>Dap4SaxHandler Class</h4>
This example defines a class as a subclass of the
<i>SaxEventHandler</i> class;
this example class would be created by the developer.
<p>
There are two parts of most interest: element plus map
creation, and event processing.

<h5>Map Creation</h5>
The construction of the <i>elementmap</i> and
<i>attributemap</i> maps is done once at the module level.
<pre>
01 def static() :
02   global elementmap, attributemap
03   elementmap = {}
04   attributemap = {}
05   elementmap["Group"] = Lexeme("Group",DATASET_,_DATASET,
07                           ("name","dapversion","ddxversion",
08                            "ns","base","xmlns"))
09     ...
10   attributemap["base"] = Lexeme("base",ATTR_BASE)
11     ...
12 # end def static
13 
14 static() # Invoke static construction
</pre>
The maps are populated with dictionary insertions (lines 5 and 10).
Note the ordered list of attribute names
that is the last argument of the <i>Lexeme("Dataset"...)</i>
constructor (line 6-8). Note also that the attribute map insertion names
(the key of the attributemap entry) should be lower case.
<p>
This example uses a java-like cliche for defining static
data, where "static" means defining module level data that
will never change.  A module level <i>static</i> function is
defined to create the maps as module level objects (lines
2-4). Then it inserts dictionary entries into the elementmap
and attributemap.  In each case, the entry maps
string->Lexeme, where the string is the element or attribute
name and the Lexeme hold information about the element or
attribute. finally, the <i>static</i>() method is invoked to
do static initialization.

<h5>Constructor</h5>
<pre>
01   def __init__(self, document, pushparser) :
02     SaxEventHandler.__init__(self,document)
03     self.pushparser = pushparser
04     self.accepted = False
05     self.textok = False
</pre>
The constructor initializes its superclass (line 2).
It then saves the passed in instance of the push parser (line 3).
It also sets some flags for later use (lines 4-5).

<h5>The yyevent() Method Part 1</h5>
The most important part of the Dap4SaxEventHandler class
is the <i>yyevent</i> method. It takes
a SaxEvent, converts it to a form usable by by the Bison
push parser, and invokes the push parser.
<p>
<pre>
01   def yyevent(self,saxtoken) :
02     if(accepted)
03       raise SAXException("yyevent called after parser has accepted");
04     event = saxevent.event
05     name = saxevent.name;
06     yytoken = 0
07     attr = None
08     element = None
09     if name in elementmap : element = elementmap[name]
10         ...
</pre>
To begin with, a check is made to ensure that the event processor it not
invoked after the parser has entered an accept state (lines 2-3).
Next, yyevent probes the element map to see if the
<i>SaxEvent</i> name field is known (line 9).

<h5>The yyevent() Method Part 2</h5>
<pre>
01     if (event == STARTELEMENT) :
02       if(element == None) : # undefined
03         yytoken = UNKNOWN_ELEMENT_
04       else:
05         yytoken = element.open
06         # Check for the special case of <Value>
07         if(yytoken == VALUE_) :
08           textok = True
09 
10     elif (event == ATTRIBUTE) :
11       attr = None
12       if tolowercase(name) in attributemap:
13         attr = attributemap[tolowercase(name)]
14       if(attr == None) :
15         yytoken = UNKNOWN_ATTR
16       else :
17         yytoken = attr.atoken
</pre>
The STARTELEMENT case checks to see if the element name was
in the element map (line 2). If it is undefined, then use
the Bison token integer <i>UNKNOWN_ELEMENT_</i>. Otherwise,
use the token specified by the element's lexeme open field
(line 5).
<p>
When the special case of the &lt;VALUE_&gt; 
element is found, set the textok flag (lines 7-8).
<p>
For the ATTRIBUTE event case (line 10), the attributemap
is probed to see if the attribute name is known.
If not, then the special token UNKNOWN_ATTR is used as the token
for the parser. Otherwise, the <i>atoken</i> field is used
as the parser token.
<p>
Most of the other switch arms are obvious; they just map to a Bison
token integer and exit the switch.

<h5>The yyevent() Method Part 3</h5>
<pre>
01     status = 0
02     try :
03       status = pushparser.push_parse(yytoken,saxevent)
04     except Exception as e:
05       raise SAXException(str(e))
06     if(status == YYABORT):
07        raise SAXException("YYABORT")
08     elif(status == YYACCEPT):
09       accepted = true;
</pre>
The Bison push parser's push_parse method is invoked with the Bison
integer token computed in the prior switch and with the <i>SaxEvent</i>
as the lval (line 3). Exceptions from the parser are just rethrown as a
SAXException (line 5).
<p>
If the parser aborts, a corresponding abort exception is thrown (lines 6-7).
If the parser accepts, then this is noted so that the code can
complain if an attempt is made to continue parsing (lines 8-9).

<h2 class="break"><a name="yax"><u>Appendix: The yax C Language library API</u></a></h2>
The yax library is a support library used by the Bison-level
lexer to produce tokens for the Bison grammar.
It is a lexer for XML documents (or at least a subset thereof)
that returns a sequence of tokens corresponding to the lexical
tokens in the XML document.

<h3>yax Token Structure</h3>
The yax token type &mdash; <i>yax_token</i>
contains information about each token extracted from the input document.
<pre>
typedef struct yax_token {
    yax_tokentype tokentype;
    char *name;
    char *text;
    int charno;
} yax_token;
</pre>
The meaning of the fields is as follows.
<ol>
<li> tokentype - a small integer giving the type of this token.
<li> name - a null terminated string indicating the name
of an element or an attribute.
<li> text - a null terminated string indicating the value
of an attribute or the contents of the text content of an element.
<li> charno - the offset in the document of the start of this token.
</ol>
Note that, depending on the token type, either the name field or the text
field may be undefined in value.
<p>
The tokentype may have one of the following values,
with associated meaning. Unless otherwise specified,
the name and text fields are undefined.
<ul>
<li> YAX_EOF &ndash; the document has no more tokens.
<li> YAX_OPEN &ndash; &lt;element...&gt;; name is the element name.
<li> YAX_CLOSE &ndash; &lt;/element...&gt;; name is the element name.
<li> YAX_EMPTYCLOSE ndash; .../&gt;; name is the element name.
<li> YAX_ATTRIBUTE ndash; &lt;... x="y"... ; name is the attribute name,
text is the attribute value (excluding any surrounding quotes.
<li> YAX_TEXT ndash; &lt;element&gt;......&lt;/element&gt;; the text field is defined
as the text inside of an element.
<li> YAX_CDATA ndash; &lt;![CDATA[...]]&gt;; the text field contains the text
between the second '[' and the last ']]'.
<li> YAX_PROLOG ndash; &lt;?xml version="1.0"?&gt;; the text field contains the version.
<li> YAX_DOCTYPE ndash; &lt;!DOCTYPE startsymbol ...&gt;; the name
field contains the start symbol, the text symbol contains everything
from the startsymbol to the final '&gt;'.
<li> YAX_COMMENT ndash; &lt;!-- ... --&gt;; the text
field contains everything between "&lt;!--" and "--&gt;".
</ul>

<h3>The yax API procedures</h3>

<h4><u>yax_err yax_create(const char* input, int flags, yax_lexer** lexerp);</u></h4>
This procedure creates an opaque lexer object of type <i>yax_lexer*</i>
to hold information about the lexical processing of the input file.
<p>
<i>Arguments</i>:
<ul>
<li> input - an in-memory string containing the xml document. This string
will not be modified, although a copy will be created as part of the
<i>yax_lexer</i>
<li> flags - a set of flags for controlling behavior of yax.
<li> lexerp - a pointer into which a pointer to an instance of yax_lexer
will be stored.
</ul>
<i>Return Value</i>:
a small integer of type <i>yax_err</i>
indicating an error condition.
The full set of errors is defined in the file "yax.h".
</ul>
<p>
The set of flags are as follows.
<ul>
<li>YXFLAG_NONE
<li>YXFLAG_ESCAPE &ndash; convert \n,\r, etc to \\ form.
<li>YXFLAG_NOCR &ndash; delete \r.
<li>YXFLAG_ELIDETEXT &ndash; only print the first 12 characters of text.
<li>YXFLAG_TRIMTEXT &ndash; remove leading and trailing whitespace;
if result is empty, then ignore the whole text.
</ul>

<h4><u>yax_err yax_free(yax_lexer* lexer);</u></h4>
This procedure frees any resources associated with the lexer.
<p>
<i>Arguments</i>:
<ul>
<li> lexer - the lexer object to be free'd.
</ul>
<i>Return Value</i>: <i>yax_err</i>.
</ul>

<h4><u>void yax_setflags(yax_lexer* lexer, int newflags);</u></h4>
Change the set of flags associated with a yax_lexer object.
<p>
<i>Arguments</i>:
<ul>
<li> lexer - the lexer object.
<li> newflags - the new set of flags for the lexer.
</ul>
<i>Return Value</i>: N.A.
</ul>

<h4><u>int yax_getflags(yax_lexer* lexer);</u></h4>
Return the current set of flags associated with a yax_lexer object.
<p>
<i>Arguments</i>:
<ul>
<li> lexer - the lexer object.
</ul>
<i>Return Value</i>: the set of flags.
</ul>

<h4><u>yax_err yax_nexttoken(yax_lexer* lexer, yax_token* token);</u></h4>
This procedure returns the next yax token from the xml document.
<p>
<i>Arguments</i>:
<ul>
<li> lexer - the lexer object representing the document being processed.
<li> token - the next token from the document. The caller is responsible
for providing the token instance; it will be filled in by this
procedure.
</ul>
<i>Return Value</i>: <i>yax_err</i>.
</ul>

<h4><u>char* yax_unescape(char* s, char** translations);</u></h4>
Given a null terminated string, scan it for Entities
(e.g. &amp;amp;) and convert them to the actual represented
character. The returned string must be free'd by the caller.
<p>
<i>Arguments</i>:
<ul>
<li> s - the string potentially containing entities.
<li> translations - provide a list
of the legal entities to recognize and translate.
The translations argument is in envv form
with position n being the entity name and
position n+1 being the translation. The list is terminated
with NULL.
</ul>
<i>Return Value</i>: a string with the entities translated.
</ul>

<h4><u>const char* yax_errstring(yax_err err);</u></h4>
Given an error of type <i>yax_err</i>,
this procedure returns a human readable error message.
<p>
<i>Arguments</i>:
<ul>
<li> err - the error value.
</ul>
<i>Return Value</i>: a string describing the error.
</ul>

<h4><u>yax_token* yax_tokendup(yax_token token);</u></h4>
Duplicate a token instance into a heap copy.
<p>
<i>Arguments</i>:
<ul>
<li> token - the token to duplicate. WARNING: note that
it is the token instance, not a pointer to a token instance.
</ul>
<i>Return Value</i>: a heap pointer to a duplicate of the token
argument, or NULL if out of memory.
</ul>

<h4><u>char* yax_trace(yax_lexer* lexer, yax_token* token);</u></h4>
This is primarily a debugging tool. Given a token,
it provides a printable string describing the fields of the token.
The caller must free the returned string.
A NULL return value signals out of memory.
<p>
<i>Arguments</i>:
<ul>
<li> lexer - yax lexer.
<li> token - the token for which a printable description is desired.
</ul>
<i>Return Value</i>: a string describing the token.
</ul>

<h2 class="break"><a name="perfecthash"><u>Appendix: Perfect Hashing</u></a></h2>
In many parsers, it can be useful to quickly convert a name (e.g. an element or
attribute name) returned by yax_nexttoken() to a corresponding Bison token.
One way to do this is to use a perfect hash function.
<p>
The example provided in the yax source tree, dap4.gperf, uses
the GNU gperf program to produce the perfect hash procedures.
The skeleton of the .gperf file is something like this.
The first three lines are directives to gperf.
<pre>
01 %define lookup-function-name XXX_keyword_lookup
02 %readonly-tables
03 %global-table
04 
05 %{
06 /*insert any necessary #include directives here*/
07 #include &lt;string.h&gt;
08 #include "yxlist.h"
09 #include "yax.h"
10 ...
11 %}
12 
13 %struct-type
14 00 struct dap4_keyword {
15   char *name; int opentag ; int closetag; int attributetag;
16 } keyword;
17 %%
18 /* Define the element names */
19 Element1, ELEMENT1OPEN, ELEMENT1CLOSE, 0
20 Element2, ELEMENT2OPEN, ELEMENT2CLOSE, 0
21 ...
22 /* Define the attribute names */
23 attr1, 0, 0, ATTR1
24 attr2, 0, 0, ATTR2
25 ...
26 %%
</pre>
<p>
The command to produce the perfect hash code is as follows.
<pre>
gperf xxx.gperf > xxx.c
</pre>
where xxx is whatever name you choose.
<p>
Within yylex, typical code might be as follows.
<pre>
01 const struct dap4_keyword* keyword;
02 if(yaxtoken->name != NULL)
03 keyword = dap4_keyword_lookup(yaxtoken->name, strlen(tokenstate->name));
</pre>
The perfect hash function will return a pointer to an instance
of this struct as determined by the name field.
If the struct is NULL then it means it is an unknown name.
Otherwise, it gives, for elements, the Bison open and close tokens.
For attributes, it gives the specific Bison attribute token.

<h2><a name="references"><u>References</u></a></h2>
<ol>
<li> http://relaxng.org
<li>http://docs.opendap.org/index.php/OPULS_Development#DAP4_Specification
<li>http://www.gnu.org/software/gperf/
</ol>

<h2><a name="changelog"><u>Change Log</u></a></h2>
<b>Version 1.0:</b>
<ul>
<li>10/31/2012 &ndash; (1) Get rid of the sorted attributes,
(2) use element and attribute maps in Java Dom lexer (3) revise the DomLexer
interface.
<li>10/27/2012 &ndash; Removed the old sax discussion
in favor the Bison push-parse model.
<li>7/24/2012 &ndash; Updated the manual to include a
    description of the Java Implementation
<li>7/23/2012 &ndash; Added the Java implementation
<li>7/15/2012 &ndash; Added a detailed discussion of xml.y
<li>7/9/2012 &ndash; Initial draft.
</ul>

</body>
</html>
